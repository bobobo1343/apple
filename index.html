<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>iTunes Style Player with Playlists</title>
<style>
  /* Basic reset and iTunes style layout */
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
      Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    margin: 0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    background: #f0f0f0;
  }
  header {
    background: #007aff;
    color: white;
    padding: 10px 20px;
    font-weight: 600;
    font-size: 1.5em;
  }
  main {
    flex: 1;
    display: flex;
    overflow: hidden;
  }
  /* Sidebar for playlists */
  #playlists {
    width: 220px;
    background: #ffffff;
    border-right: 1px solid #ccc;
    padding: 10px;
    display: flex;
    flex-direction: column;
  }
  #playlists h2 {
    margin-top: 0;
    font-size: 1.2em;
    margin-bottom: 10px;
  }
  #playlistList {
    flex: 1;
    overflow-y: auto;
  }
  #playlistList button {
    width: 100%;
    padding: 8px 6px;
    margin-bottom: 4px;
    border: none;
    background: #eee;
    cursor: pointer;
    text-align: left;
    border-radius: 3px;
    font-size: 1em;
  }
  #playlistList button.active {
    background: #007aff;
    color: white;
    font-weight: bold;
  }
  #btnNewPlaylist {
    margin-top: 10px;
    padding: 8px;
    font-size: 1em;
    cursor: pointer;
    background: #007aff;
    color: white;
    border: none;
    border-radius: 3px;
  }

  /* Track list area */
  #trackSection {
    flex: 1;
    display: flex;
    flex-direction: column;
  }
  #searchContainer {
    padding: 10px;
    background: #fff;
    border-bottom: 1px solid #ccc;
  }
  #searchInput {
    width: 100%;
    padding: 8px 6px;
    font-size: 1em;
    border-radius: 3px;
    border: 1px solid #ccc;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    background: white;
  }
  thead tr {
    background: #ddd;
  }
  th, td {
    padding: 8px 6px;
    text-align: left;
    border-bottom: 1px solid #ccc;
  }
  tr.playing {
    background: #dbe9ff;
  }
  tr:hover {
    background: #f0f8ff;
    cursor: pointer;
  }
  button.btnAddTrack, button.btnRemoveTrack {
    background: transparent;
    border: none;
    font-size: 1.2em;
    cursor: pointer;
  }
  button.btnAddTrack:hover {
    color: green;
  }
  button.btnRemoveTrack:hover {
    color: red;
  }

  /* Player controls */
  #playerControls {
    background: #007aff;
    color: white;
    padding: 12px 20px;
    display: flex;
    align-items: center;
  }
  #btnPlayPause, #btnPrev, #btnNext {
    cursor: pointer;
    font-size: 1.5em;
    margin: 0 10px;
    background: transparent;
    border: none;
    color: white;
  }
  #progressContainer {
    flex: 1;
    height: 10px;
    background: rgba(255,255,255,0.4);
    border-radius: 5px;
    margin: 0 15px;
    position: relative;
    cursor: pointer;
  }
  #progressBar {
    height: 100%;
    background: white;
    width: 0%;
    border-radius: 5px;
  }
  #timeDisplay {
    font-size: 0.9em;
    width: 80px;
    text-align: right;
  }
</style>
</head>
<body>
<header>iTunes Style Music Player</header>
<main>
  <aside id="playlists">
    <h2>Playlists</h2>
    <div id="playlistList">
      <!-- Playlists buttons inserted here -->
    </div>
    <button id="btnNewPlaylist">+ New Playlist</button>
  </aside>
  <section id="trackSection">
    <div id="searchContainer">
      <input type="search" id="searchInput" placeholder="Search tracks..." aria-label="Search tracks" />
    </div>
    <table id="tracklist" aria-label="Track list">
      <thead>
        <tr>
          <th>#</th>
          <th>Title</th>
          <th>Artist</th>
          <th>Album</th>
          <th>Genre</th>
          <th>Duration</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="tracklistBody">
        <!-- Tracks inserted here -->
      </tbody>
    </table>
  </section>
</main>
<footer id="playerControls">
  <button id="btnPrev" aria-label="Previous">&#9664;&#9664;</button>
  <button id="btnPlayPause" aria-label="Play">&#9654;</button>
  <button id="btnNext" aria-label="Next">&#9654;&#9654;</button>
  <div id="progressContainer" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" tabindex="0" aria-label="Playback progress">
    <div id="progressBar"></div>
  </div>
  <div id="timeDisplay" aria-live="polite" aria-atomic="true">0:00 / 0:00</div>
</footer>

<script>
(() => {
  // Your Google Drive API key and folder ID here
  const API_KEY = "AIzaSyDsYE91wH7UDwu8eZNbD1CFuVcilgYeZhI";
  const FOLDER_ID = "1DGz9zEQh29EAqTZpmWK5mwSj5HComnkn";

  const playlistList = document.getElementById("playlistList");
  const btnNewPlaylist = document.getElementById("btnNewPlaylist");
  const tracklistBody = document.getElementById("tracklistBody");
  const searchInput = document.getElementById("searchInput");

  const btnPlayPause = document.getElementById("btnPlayPause");
  const btnNext = document.getElementById("btnNext");
  const btnPrev = document.getElementById("btnPrev");
  const progressContainer = document.getElementById("progressContainer");
  const progressBar = document.getElementById("progressBar");
  const timeDisplay = document.getElementById("timeDisplay");

  const audio = new Audio();
  audio.preload = "metadata";

  let tracks = [];
  let playlists = {};
  let currentPlaylist = "All Songs";
  let filteredTracks = [];
  let currentTrackIndex = -1;
  let isPlaying = false;

  // Helper to format seconds to mm:ss
  function formatTime(secs) {
    if (isNaN(secs) || secs <= 0) return "0:00";
    const m = Math.floor(secs / 60);
    const s = Math.floor(secs % 60);
    return `${m}:${s.toString().padStart(2, "0")}`;
  }

  // Fetch Google Drive files from folder with pagination
  async function fetchDriveFiles(pageToken = "") {
    try {
      let url = `https://www.googleapis.com/drive/v3/files?key=${API_KEY}&q='${FOLDER_ID}'+in+parents+and+trashed=false&fields=nextPageToken,files(id,name,mimeType)&pageSize=1000`;
      if (pageToken) url += `&pageToken=${pageToken}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Drive API error: ${res.status}`);
      const data = await res.json();
      return data;
    } catch (e) {
      alert("Error loading files from Google Drive: " + e.message);
      return null;
    }
  }

  // Parse filename into metadata
  function parseTrackMetadata(filename, index) {
    let baseName = filename.replace(/\.[^/.]+$/, "");
    let parts = baseName.split(" - ");
    return {
      id: null,
      trackNumber: index + 1,
      title: parts[1] || parts[0] || filename,
      artist: parts[2] || "Unknown Artist",
      album: parts[3] || "Unknown Album",
      genre: parts[4] || "Unknown Genre",
      duration: 0,
      fileName: filename,
      mimeType: "",
      fileId: null,
      url: "",
    };
  }

  // Build playable URL to avoid CORS
  function buildPlayableUrl(fileId) {
    return `https://drive.google.com/uc?export=download&id=${fileId}`;
  }

  // Load durations asynchronously
  async function loadTrackDurations() {
    for (let i = 0; i < tracks.length; i++) {
      const track = tracks[i];
      try {
        track.duration = await new Promise((resolve) => {
          const au = new Audio();
          au.src = track.url;
          au.preload = "metadata";
          au.addEventListener("loadedmetadata", () => {
            resolve(au.duration);
            au.remove();
          });
          au.addEventListener("error", () => {
            resolve(0);
            au.remove();
          });
        });
      } catch {
        track.duration = 0;
      }
    }
  }

  // Load all tracks from Drive folder
  async function loadTracks() {
    let allFiles = [];
    let pageToken = "";
    do {
      const data = await fetchDriveFiles(pageToken);
      if (!data) break;
      allFiles = allFiles.concat(data.files);
      pageToken = data.nextPageToken || "";
    } while (pageToken);

    tracks = allFiles
      .filter(f => f.mimeType.startsWith("audio/"))
      .map((f, idx) => {
        const track = parseTrackMetadata(f.name, idx);
        track.fileId = f.id;
        track.mimeType = f.mimeType;
        track.url = buildPlayableUrl(f.id);
        track.id = f.id;
        return track;
      });

    playlists = { "All Songs": [...tracks] };
    currentPlaylist = "All Songs";

    await loadTrackDurations();

    applyFiltersAndRender();
    renderPlaylists();

    currentTrackIndex = -1;
  }

  // Render playlist buttons
  function renderPlaylists() {
    playlistList.innerHTML = "";
    Object.keys(playlists).forEach(plName => {
      const btn = document.createElement("button");
      btn.textContent = plName;
      btn.className = plName === currentPlaylist ? "active" : "";
      btn.onclick = () => {
        currentPlaylist = plName;
        applyFiltersAndRender();
        renderPlaylists();
      };
      playlistList.appendChild(btn);
    });
  }

  // Render tracks table
  function renderTrackList(tracksToRender) {
    tracklistBody.innerHTML = "";
    tracksToRender.forEach((track, i) => {
      const tr = document.createElement("tr");
      tr.className = i === currentTrackIndex ? "playing" : "";
      tr.tabIndex = 0;
      tr.innerHTML = `
        <td>${track.trackNumber}</td>
        <td>${track.title}</td>
        <td>${track.artist}</td>
        <td>${track.album}</td>
        <td>${track.genre}</td>
        <td>${formatTime(track.duration)}</td>
        <td>${
          currentPlaylist === "All Songs"
            ? `<button class="btnAddTrack" aria-label="Add to playlist">＋</button>`
            : `<button class="btnRemoveTrack" aria-label="Remove from playlist">×</button>`
        }</td>
      `;
      // Click row to play track
      tr.addEventListener("click", (e) => {
        if (
          e.target.classList.contains("btnAddTrack") ||
          e.target.classList.contains("btnRemoveTrack")
        ) {
          return; // don't play if clicked button
        }
        playTrack(i);
      });
      // Add button event
      if (currentPlaylist === "All Songs") {
        tr.querySelector(".btnAddTrack").addEventListener("click", (e) => {
          e.stopPropagation();
          addTrackToPlaylist(i);
        });
      } else {
        // Remove button event
        tr.querySelector(".btnRemoveTrack").addEventListener("click", (e) => {
          e.stopPropagation();
          removeTrackFromPlaylist(i);
        });
      }
      tracklistBody.appendChild(tr);
    });
  }

  // Add track to current playlist (if not All Songs)
  function addTrackToPlaylist(trackIndex) {
    if (currentPlaylist === "All Songs") {
      alert("Cannot add tracks to 'All Songs' playlist.");
      return;
    }
    const track = filteredTracks[trackIndex];
    if (!track) return;
    const plTracks = playlists[currentPlaylist];
    if (plTracks.find(t => t.fileId === track.fileId)) {
      alert("Track already in playlist.");
      return;
    }
    plTracks.push(track);
    applyFiltersAndRender();
  }

  // Remove track from current playlist (if not All Songs)
  function removeTrackFromPlaylist(trackIndex) {
    if (currentPlaylist === "All Songs") {
      alert("Cannot remove tracks from 'All Songs' playlist.");
      return;
    }
    const plTracks = playlists[currentPlaylist];
    const track = filteredTracks[trackIndex];
    if (!track) return;
    const idxInPlaylist = plTracks.findIndex(t => t.fileId === track.fileId);
    if (idxInPlaylist === -1) {
      alert("Track not found in playlist.");
      return;
    }
    plTracks.splice(idxInPlaylist, 1);
    applyFiltersAndRender();
  }

  // Filter by search, update filteredTracks, and render track list
  function applyFiltersAndRender() {
    const searchTerm = searchInput.value.trim().toLowerCase();
    let plTracks = playlists[currentPlaylist] || [];
    filteredTracks = plTracks.filter(t => {
      if (!searchTerm) return true;
      return (
        t.title.toLowerCase().includes(searchTerm) ||
        t.artist.toLowerCase().includes(searchTerm) ||
        t.album.toLowerCase().includes(searchTerm) ||
        t.genre.toLowerCase().includes(searchTerm)
      );
    });
    renderTrackList(filteredTracks);
  }

  // Play selected track
  function playTrack(index) {
    if (index < 0 || index >= filteredTracks.length) return;
    currentTrackIndex = index;
    audio.src = filteredTracks[index].url;
    audio.play().catch(() => {});
    isPlaying = true;
    updatePlayPauseButton();
    renderTrackList(filteredTracks);
  }

  // Update play/pause button icon
  function updatePlayPauseButton() {
    btnPlayPause.textContent = isPlaying ? "❚❚" : "▶";
  }

  // Player controls
  btnPlayPause.addEventListener("click", () => {
    if (isPlaying) {
      audio.pause();
      isPlaying = false;
    } else {
      if (currentTrackIndex === -1 && filteredTracks.length > 0) {
        playTrack(0);
      } else {
        audio.play().catch(() => {});
        isPlaying = true;
      }
    }
    updatePlayPauseButton();
  });
  btnNext.addEventListener("click", () => {
    playTrack((currentTrackIndex + 1) % filteredTracks.length);
  });
  btnPrev.addEventListener("click", () => {
    playTrack((currentTrackIndex - 1 + filteredTracks.length) % filteredTracks.length);
  });

  // Update progress bar
  audio.addEventListener("timeupdate", () => {
    if (!audio.duration || isNaN(audio.duration)) return;
    const percent = (audio.currentTime / audio.duration) * 100;
    progressBar.style.width = percent + "%";
    timeDisplay.textContent = `${formatTime(audio.currentTime)} / ${formatTime(audio.duration)}`;
  });

  // Seek on progress bar click
  progressContainer.addEventListener("click", (e) => {
    const rect = progressContainer.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const ratio = Math.min(Math.max(clickX / rect.width, 0), 1);
    if (audio.duration && !isNaN(audio.duration)) {
      audio.currentTime = ratio * audio.duration;
    }
  });

  // Search filter input event
  searchInput.addEventListener("input", () => {
    applyFiltersAndRender();
  });

  // Create new playlist
  btnNewPlaylist.addEventListener("click", () => {
    let name = prompt("Enter new playlist name:");
    if (!name) return;
    if (playlists[name]) {
      alert("Playlist already exists.");
      return;
    }
    playlists[name] = [];
    currentPlaylist = name;
    renderPlaylists();
    applyFiltersAndRender();
  });

  // Initial load of tracks
  loadTracks();
})();
</script>
</body>
</html>
